
# Кеширование
Напомню, что однажды создав image (образ) мы его больше не можем его менять или обновлять. То есть мы изолируем наш текущий код от любого внешнего воздействия (фиксируем состояние кода), чтобы внешняя среда уже никак не могла повлиять на его работу. И кстати именно поэтому любые продукты работы приложения (если такие имеются), мы не сможем увидеть в папке нашего оригинального приложения. Так как любые продукты работы откладываются теперь в запущенном контейнере, а не в нашем исходном коде/приложении. Наше оригинальное приложение никак не меняется. Потому что наше оригинально приложение и image - это две разные вещи.

Поэтому возникает вопрос. Что делать если я внес изменения в свой проект и теперь хочу, чтобы этот функционал теперь появился и в image, и в последующе запущенном контейнере?

Так как любой образ иммутабельный, и мы никак не можем обновить уже созданный/существующий образ, то под новые изменения, нам остается только создать новый образ - `docker build <APP_PATH>`. И при этом каждый из images будет представлять какую-то конкретную версию приложения "застывшею во времени".

Но, чтобы боротся с таким базовым поведением из коробки, у Докера есть хорошая система кеширования, которая может помочь упростить нам процесс создания нового образа и сделать его менее ресурсозатратным и более быстрым для системы. Мы просто немного обновим логику в Dockerfile и перед `RUN npm install` добавим поле - `COPY package.json /app`:
```
FROM node 
WORKDIR /app
COPY package.json /app (или 'package.json .' - это одно и тоже самое)
RUN npm install
COPY . .
CMD [ "npm", "start" ]
EXPOSE 3000
```
Теперь при новой сборке образа, мы пердварительно будем проверять есть ли у нас какие либо изменения в package.json, то есть - есть ли у нас изменения в наших модулях. И если их нет, то мы не будем по новой каждый раз тратить ресурсы на повторную установку необходимых нам для работы модулей, а просто будем брать их из кеша, что значительно ускорит создание нового образа.

# Полезные команды
Подключиться к уже запущенному контейнеру: `docker attach <CONTAINER_ID_or_Name>`
Посмотреть, что происходило в контейнере (какие логи выводились в консоль): `docker logs <CONTAINER_ID_or_Name>`

# Параметры которые мы можем добавлять при запуске нового контейнера
`docker run -d -p 3000:3000 --name container_name <IMAGE_ID>`
'--name container_name' - имя которое мы можем сами задать контейнеру. И теперь нам не нужно помнить ID контейнера для его запуска/остановки, мы можем запустить по нашему созданому имени
'--rm' - этот параметр автоматически удаляет контейнер сразу как только мы останавливаем его работу. Помогает нам не откладывать в нашей памяти куча не нужных контейнеров при каждом новом запуске образа

# Повышаем удобство работы
Так как при каждом запуске образа каждый раз обращаться к нему по его ID-шнику не удобно, то для каждого нового обаза, в момент его создания, мы можем задавать ему свое имя и/или специальные теги при его зборке
'-t image_name' - имя которое мы даем образу при его создании
`'docker build -t image_name .'`
После чего мы теперь можем создавать контейнеры не по ID-шнику нашего образа, а по ранее присвоеному ему имени
`'docker run -d -p 3000:3000 --rm --name container-name image_name'`: создаем и запускаем контейнер в “detached” режиме, на порте 3000, под именем container-name, на онове образа image_name, который самоудаляется после завершения процесса (--rm)

Также для наших image можно задавать Теги (версии) при их создании. То есть мы можем создать много образов с одинаковым именем но дать всем им разные теги. В итоге это можно использовать чтобы для разных версий одного и того же приложения не придумавать каждый раз новое имя, а просто давать этому приложению разные Теги, которые будут служить как бы именем его версии.
Для этого, при создании образа, когда мы задаем ему имя - просто добавим к его имени еще и название его тега(версии) ':version_tag'
`'docker build -t image_name:version_tag .'`
И тогда при запуске контейнера мы можем указывать какую версию приложения мы хотим запустить исходя из его тега:
`'docker run -d -p 3000:3000 --rm --name container-name image_name:version_tag'`
Но если мы самостоятельно не задаем тег при наименовании образа, то докер создаст его автоматически за нас. И зачастую он присваивает имя тега - 'latest'
